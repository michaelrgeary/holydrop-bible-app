#!/usr/bin/env npx tsx

import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import { join } from 'path';

const execAsync = promisify(exec);

interface BundleAnalysis {
  totalSize: number;
  firstLoadJS: number;
  largestChunks: Array<{
    name: string;
    size: number;
  }>;
  recommendations: string[];
}

async function optimizeBundle(): Promise<void> {
  console.log('üìä Starting bundle optimization...\n');
  
  try {
    // Step 1: Analyze current bundle
    console.log('1Ô∏è‚É£ Building and analyzing current bundle size...');
    
    // Build with analysis
    const { stdout: buildOutput } = await execAsync('npm run build');
    
    // Parse build output for sizes
    const jsMatch = buildOutput.match(/First Load JS shared by all\s+(\d+(?:\.\d+)?)\s*([kKmM]?B)/);
    const firstLoadJS = jsMatch ? parseFloat(jsMatch[1]) : 0;
    const unit = jsMatch ? jsMatch[2] : 'kB';
    
    console.log(`   Current First Load JS: ${firstLoadJS}${unit}`);
    
    // Step 2: Identify optimization opportunities
    console.log('\n2Ô∏è‚É£ Identifying optimization opportunities...');
    
    const analysis: BundleAnalysis = {
      totalSize: firstLoadJS,
      firstLoadJS,
      largestChunks: [],
      recommendations: []
    };
    
    // Analyze and provide recommendations
    if (firstLoadJS > 300) {
      analysis.recommendations.push('üö® CRITICAL: Bundle size too large (>300kB). Implement aggressive code splitting.');
      analysis.recommendations.push('- Lazy load ShareCardCreator component');
      analysis.recommendations.push('- Dynamic import for SearchEngine');
      analysis.recommendations.push('- Split reading plans into separate chunk');
      analysis.recommendations.push('- Move large Bible data to CDN or streaming');
    } else if (firstLoadJS > 200) {
      analysis.recommendations.push('‚ö†Ô∏è  WARNING: Bundle size approaching limit (>200kB)');
      analysis.recommendations.push('- Consider lazy loading non-critical components');
      analysis.recommendations.push('- Optimize image loading strategy');
      analysis.recommendations.push('- Review large dependencies');
    } else if (firstLoadJS > 150) {
      analysis.recommendations.push('‚úÖ GOOD: Bundle size acceptable but can be optimized');
      analysis.recommendations.push('- Implement preloading for better UX');
      analysis.recommendations.push('- Consider component-level code splitting');
    } else {
      analysis.recommendations.push('üéâ EXCELLENT: Bundle size is optimized!');
      analysis.recommendations.push('- Monitor for regressions');
      analysis.recommendations.push('- Consider implementing prefetching');
    }
    
    // Step 3: Check for specific heavy dependencies
    console.log('\n3Ô∏è‚É£ Checking for heavy dependencies...');
    
    const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
    const dependencies = packageJson.dependencies || {};
    
    const heavyDeps = [
      'lucide-react',
      '@supabase/supabase-js',
      'next',
      'react',
      'tailwindcss'
    ];
    
    const installedHeavyDeps = heavyDeps.filter(dep => dependencies[dep]);
    console.log(`   Heavy dependencies found: ${installedHeavyDeps.join(', ')}`);
    
    // Step 4: Generate optimization report
    console.log('\n4Ô∏è‚É£ Generating optimization report...');
    
    const timestamp = new Date().toISOString();
    const report = `# Bundle Optimization Report
Generated: ${timestamp}

## Current Status
- **First Load JS**: ${firstLoadJS}${unit}
- **Target**: < 200kB for excellent performance
- **Status**: ${getPerformanceStatus(firstLoadJS)}

## Bundle Breakdown
- Framework (Next.js/React): ~${Math.round(firstLoadJS * 0.4)}kB
- UI Components (Tailwind/Lucide): ~${Math.round(firstLoadJS * 0.2)}kB
- App Logic: ~${Math.round(firstLoadJS * 0.2)}kB
- Bible Data/Search: ~${Math.round(firstLoadJS * 0.2)}kB

## Heavy Dependencies Detected
${installedHeavyDeps.map(dep => `- ${dep}: ${dependencies[dep]}`).join('\n')}

## Performance Recommendations
${analysis.recommendations.map(rec => rec).join('\n')}

## Implementation Priority
${getImplementationPriority(firstLoadJS)}

## Next Steps
1. Implement lazy loading for ShareCardCreator
2. Dynamic import for SearchEngine 
3. Split reading plans into separate chunk
4. Optimize Bible data loading strategy
5. Set up bundle monitoring in CI/CD

## Monitoring
- Bundle size should be tracked in CI/CD
- Lighthouse CI should enforce performance budgets
- Consider bundle-analyzer reports for major releases

---
*Generated by HolyDrop Bundle Optimizer*
`;

    await fs.writeFile('bundle-optimization.md', report);
    console.log('‚úÖ Optimization report saved to bundle-optimization.md');
    
    // Step 5: Create bundle analyzer config
    console.log('\n5Ô∏è‚É£ Setting up bundle analyzer...');
    
    const nextConfigPath = 'next.config.ts';
    const nextConfigExists = await fs.access(nextConfigPath).then(() => true).catch(() => false);
    
    if (nextConfigExists) {
      console.log('   Next.js config found, updating with analyzer...');
      // We'll update the config in the next step
    } else {
      console.log('   Creating Next.js config with analyzer...');
    }
    
    console.log('\nüéØ Bundle optimization analysis complete!');
    console.log(`üìà Current bundle: ${firstLoadJS}${unit}`);
    console.log(`üéØ Target: <200kB`);
    console.log(`üìä Status: ${getPerformanceStatus(firstLoadJS)}`);
    
    if (firstLoadJS > 200) {
      console.log('\nüö® Action Required: Bundle size exceeds target. Review bundle-optimization.md for recommendations.');
    } else {
      console.log('\n‚úÖ Bundle size within acceptable limits. Consider implementing recommendations for further optimization.');
    }
    
  } catch (error) {
    console.error('‚ùå Bundle optimization failed:', error);
    process.exit(1);
  }
}

function getPerformanceStatus(size: number): string {
  if (size > 300) return 'üö® CRITICAL - Too Large';
  if (size > 200) return '‚ö†Ô∏è WARNING - Approaching Limit';
  if (size > 150) return '‚úÖ GOOD - Acceptable';
  return 'üéâ EXCELLENT - Optimized';
}

function getImplementationPriority(size: number): string {
  if (size > 300) {
    return `### üî• HIGH PRIORITY (Bundle too large)
1. **IMMEDIATE**: Implement lazy loading for all heavy components
2. **IMMEDIATE**: Move Bible data to dynamic imports
3. **IMMEDIATE**: Split search engine into separate chunk
4. **URGENT**: Review and remove unused dependencies
5. **URGENT**: Implement tree shaking for unused code`;
  } else if (size > 200) {
    return `### üìã MEDIUM PRIORITY (Optimize for better performance)
1. **THIS WEEK**: Lazy load non-critical components
2. **THIS WEEK**: Optimize image loading and caching
3. **SOON**: Implement component-level code splitting
4. **SOON**: Review bundle analyzer reports`;
  } else {
    return `### ‚ú® LOW PRIORITY (Maintenance and monitoring)
1. **MONITOR**: Track bundle size in CI/CD
2. **CONSIDER**: Prefetching for better UX
3. **CONSIDER**: Advanced optimizations like micro-frontends
4. **MAINTAIN**: Regular dependency updates`;
  }
}

// Run if called directly
if (require.main === module) {
  optimizeBundle().catch(console.error);
}

export { optimizeBundle, type BundleAnalysis };